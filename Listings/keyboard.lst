C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE KEYBOARD
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE C语言版本\keyboard.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\keyboard.lst) TABS(2) SRC(.\Objects\keyboard.SRC)

line level    source

   1          //包含键盘相关的头文件
   2          #include "keyboard.h"
   3          //定义一个长度为64的无符号字符数组，用于存储输入的数字
   4          unsigned char xdata inputs[64]={0};
   5          //定义一个函数，用于扫描键盘按键，并返回按键对应的值
   6          unsigned char kscan(void)
   7          {
   8   1        //定义四个无符号字符变量，用于存储按键的高低位、按键类型和临时值
   9   1        unsigned char data keyh,keyl,keytp,temp;
  10   1        //设置P1端口的高四位为推挽输出模式
  11   1        P1MDOUT=0xF0;
  12   1        //设置P1端口的低四位为高电平，做输入
  13   1        P1=0X0F; 
  14   1        //无限循环，直到检测到按键
  15   1        while(1)
  16   1        {
  17   2        //如果P1端口的低四位不全为高电平，说明有按键按下
  18   2        if(P1!=0X0F)
  19   2        { 
  20   3          //延时10毫秒，消除抖动
  21   3          delay_ms(10);
  22   3          //再次检测P1端口的低四位，如果仍然不全为高电平，说明按键有效
  23   3          if(P1!=0x0f)
  24   3          {
  25   4            //将P1端口的低四位赋值给keyl，作为按键的低位
  26   4            keyl=P1;
  27   4            //跳出循环
  28   4            break;
  29   4          }
  30   3        }
  31   2        }
  32   1          //设置P1端口的低四位为输出模式
  33   1          P1MDOUT=0x0F;
  34   1          //设置P1端口的高四位为高电平，做输入
  35   1          P1=0xf0;
  36   1          //延时10毫秒，消除抖动
  37   1          delay_ms(10);
  38   1          //将P1端口的高四位赋值给keyh，作为按键的高位
  39   1          keyh=P1;
  40   1          //将按键的高低位进行或运算，得到按键类型
  41   1          keytp=keyh|keyl;
  42   1          //根据按键类型，用switch语句判断按键对应的值
  43   1          switch(keytp)
  44   1          {
  45   2            //如果按键类型为0xe7，对应的值为0
  46   2            case 0xe7: temp=0;break;
  47   2            //如果按键类型为0xd7，对应的值为1
  48   2            case 0xd7: temp=1;break;
  49   2            //如果按键类型为0xb7，对应的值为2
  50   2            case 0xb7: temp=2;break;
  51   2            //如果按键类型为0x77，对应的值为3
  52   2            case 0x77: temp=3;break;
  53   2            //如果按键类型为0xeb，对应的值为4
  54   2            case 0xeb: temp=4;break;
C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 2   

  55   2            //如果按键类型为0xdb，对应的值为5
  56   2            case 0xdb: temp=5;break;
  57   2            //如果按键类型为0xbb，对应的值为6
  58   2            case 0xbb: temp=6;break;
  59   2            //如果按键类型为0x7b，对应的值为7
  60   2            case 0x7b: temp=7;break;
  61   2            //如果按键类型为0xed，对应的值为8
  62   2            case 0xed: temp=8;break;
  63   2            //如果按键类型为0xdd，对应的值为9
  64   2            case 0xdd: temp=9;break;
  65   2            //如果按键类型为0xbd，对应的值为10
  66   2            case 0xbd: temp=10;break;
  67   2            //如果按键类型为0x7d，对应的值为11
  68   2            case 0x7d: temp=11;break;
  69   2            //如果按键类型为0xee，对应的值为12
  70   2            case 0xee: temp=12;break;
  71   2            //如果按键类型为0xde，对应的值为13
  72   2            case 0xde: temp=13;break;
  73   2            //如果按键类型为0xbe，对应的值为14
  74   2            case 0xbe: temp=14;break;
  75   2            //如果按键类型为0x7e，对应的值为15
  76   2            case 0x7e: temp=15;break;
  77   2            //如果按键类型不在以上范围内，不做任何操作
  78   2            default:break;
  79   2          }
  80   1        //设置P1端口的高四位为输出模式
  81   1        P1MDOUT=0xF0;
  82   1        //设置P1端口的低四位为高电平，做输入
  83   1        P1=0X0F; 
  84   1        //无限循环，直到检测到按键松开
  85   1        while(1)
  86   1        {
  87   2        //如果P1端口的低四位全为高电平，说明按键松开
  88   2        if(P1==0X0F)
  89   2        { 
  90   3          //延时10毫秒，消除抖动
  91   3          delay_ms(10);
  92   3                   
  93   3          //再次检测P1端口的低四位，如果仍然全为高电平，说明按键松开有效
  94   3          if(P1==0x0f)
  95   3          {
  96   4            //跳出循环
  97   4            break;
  98   4          }
  99   3        }
 100   2        }
 101   1        //返回按键对应的值
 102   1        return temp;
 103   1      }
 104          //定义一个函数，用于判断输入是F还是E
 105          bit f_or_e(void)
 106          {
 107   1        //定义一个无符号字符变量，用于存储按键对应的值
 108   1        unsigned temp;
 109   1        //无限循环，直到检测到有效按键
 110   1        while(1)
 111   1        {
 112   2          //调用kscan函数，获取按键对应的值
 113   2          temp=kscan();
 114   2          //如果按键对应的值为15(F)，一般情况表示继续，返回0
 115   2          if(temp==15)
 116   2          {
C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 3   

 117   3            //返回0
 118   3            return 0;
 119   3          }
 120   2          //如果按键对应的值为14(E)，表示退出，返回0
 121   2          else if(temp==14)
 122   2          {
 123   3            //返回1
 124   3            return 1;
 125   3          }
 126   2        }
 127   1      }
 128          //定义一个函数，用于输入数字，并存储在inputs数组中
 129          bit input_digits(void)
 130          {
 131   1        //定义两个无符号字符变量，用于存储循环计数和按键对应的值
 132   1        unsigned char i,digit=0;
 133   1        //定义一个位变量，用于存储是否继续或退出的状态
 134   1        bit state=0;
 135   1        //调用wait_input函数，等待输入，并获取状态
 136   1        state=wait_input();
 137   1        //如果状态为1，表示退出(输入了E)
 138   1        if(state==1)
 139   1        {
 140   2          //返回1
 141   2          return 1;
 142   2        }
 143   1        //无限循环，直到检测到有效输入
 144   1        while(1)
 145   1        {
 146   2        //调用clear函数，清屏
 147   2        clear();
 148   2        //用循环语句，将inputs数组的所有元素初始化为0
 149   2        for(i=0;i<64;i++)
 150   2        {
 151   3          inputs[i]=0;
 152   3        }
 153   2        //用循环语句，从键盘获取输入的数字，并存储在inputs数组中
 154   2        for(i=0;i<65;i++)
 155   2        {
 156   3          //调用kscan函数，获取按键对应的值
 157   3          digit=kscan();
 158   3          //如果循环计数小于64，且按键对应的值在0到9之间，表示输入的是数字
 159   3          if(i<64&digit>=0&digit<=9)
 160   3          {
 161   4            //将按键对应的值转换为ASCII码，存储在inputs数组中
 162   4            digit=inputs[i]=digits[digit];
 163   4            //根据循环计数，调用print_char函数，在不同的位置显示输入的数字
 164   4            if(i==16)
 165   4              {
 166   5                print_char(0,2,digit);
 167   5              }
 168   4            else if(i==32)
 169   4              {
 170   5                print_char(0,3,digit);
 171   5              }
 172   4            else if(i==48)
 173   4              {
 174   5                print_char(0,4,digit);
 175   5              }
 176   4            else
 177   4              {
 178   5                print_char(0,0,digit);
C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 4   

 179   5              }
 180   4          }
 181   3          //如果循环计数大于0，且按键对应的值为15，表示输入结束
 182   3          else if(i>0&digit==15)
 183   3          {
 184   4            //返回0
 185   4            return 0;
 186   4          }
 187   3          //如果按键对应的值为14，表示退出
 188   3          else if(digit==14)
 189   3          {
 190   4            //返回1
 191   4            return 1;
 192   4          }
 193   3          //如果循环计数大于0，且按键对应的值为13，表示重新输入
 194   3          else if(i>0&digit==13)
 195   3              {
 196   4                break;
 197   4              }
 198   3          //如果以上条件都不满足，表示输入无效，循环计数不变
 199   3          else
 200   3          {
 201   4            i--;
 202   4          }
 203   3        }
 204   2        }
 205   1      }
 206          //定义一个函数，用于输入位数，并存储在bits变量中
 207          bit input_bits(void)
 208          {
 209   1        //定义两个无符号字符变量，用于存储循环计数和按键对应的值
 210   1        unsigned char i,digit=0;
 211   1        //定义一个长度为2的无符号字符数组，用于存储输入的位数
 212   1        unsigned char a[2]={0};
 213   1        //定义一个位变量，用于存储是否继续或退出的状态
 214   1        bit state=0;
 215   1        //调用wait_input函数，等待输入，并获取状态
 216   1        state=wait_input();
 217   1        //如果状态为1，表示退出
 218   1        if(state==1)
 219   1        {
 220   2          //返回1
 221   2          return 1;
 222   2        }
 223   1        //无限循环，直到检测到有效输入
 224   1        while(1)
 225   1        {
 226   2        //调用clear函数，清屏
 227   2        clear();
 228   2        //用循环语句，将a数组的所有元素初始化为0
 229   2        for(i=0;i<2;i++)
 230   2        {
 231   3          a[i]=0;
 232   3        }
 233   2        //用循环语句，从键盘获取输入的位数，并存储在a数组中
 234   2        for(i=0;i<3;i++)
 235   2        {
 236   3          //调用kscan函数，获取按键对应的值
 237   3          digit=kscan();
 238   3          //如果循环计数小于2，且按键对应的值在0到9之间，表示输入的是数字
 239   3          if(i<2&digit>=0&digit<=9)
 240   3          {
C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 5   

 241   4            //将按键对应的值存储在a数组中
 242   4            a[i]=digit;
 243   4            //调用print_char函数，在指定位置显示输入的数字
 244   4            print_char(0,0,digit+48);
 245   4          }
 246   3          //如果循环计数大于0，且按键对应的值为15，表示输入结束
 247   3          else if(i>0&digit==15)
 248   3          {
 249   4            //将a数组中的两个数字组合成一个位数，存储在全局变量bits中
 250   4            if(i==1)
 251   4            {
 252   5              bits=a[0];
 253   5            }
 254   4            else
 255   4            {
 256   5            bits=a[0]*10+a[1];
 257   5            }
 258   4            //如果bits变量的值在1到64之间，表示输入的位数有效
 259   4            if(bits>=1&bits<=64)
 260   4            {
 261   5            //返回0
 262   5            return 0;
 263   5            }
 264   4            //如果bits变量的值不在1到64之间，表示输入的位数无效
 265   4            else
 266   4            {
 267   5              //调用wrong_input_bits函数，显示错误信息，并获取状态
 268   5              if(wrong_input_bits())
 269   5              {
 270   6                //如果状态为1，表示退出
 271   6                return 1;
 272   6              }
 273   5              //如果状态为0，表示继续
 274   5              else
 275   5              {
 276   6                //跳出循环
 277   6                break;
 278   6              }
 279   5            }
 280   4          }
 281   3          //如果按键对应的值为14，表示退出
 282   3          else if(digit==14)
 283   3          {
 284   4            //返回1
 285   4            return 1;
 286   4          }
 287   3          //如果循环计数大于0，且按键对应的值为13，表示重新输入
 288   3          else if(i>0&digit==13)
 289   3          {
 290   4            break;
 291   4          }
 292   3          //如果以上条件都不满足，表示输入无效，循环计数不变
 293   3          else
 294   3          {
 295   4            i--;
 296   4          }
 297   3        }
 298   2        }
 299   1      }
 300          //定义一个函数，用于输入显示时间，并存储在display_time变量中
 301          bit input_display_time(void)
 302          {
C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 6   

 303   1        //定义两个无符号字符变量，用于存储循环计数和按键对应的值
 304   1        unsigned char i,j,digit=0;
 305   1        //定义一个长度为5的无符号字符数组，用于存储输入的显示时间
 306   1        unsigned char a[5]={0};
 307   1        //定义一个无符号长整数变量，用于存储输入的显示时间
 308   1        unsigned long temp;
 309   1        //定义一个位变量，用于存储是否继续或退出的状态
 310   1        bit state=0;
 311   1        //调用wait_input函数，等待输入，并获取状态
 312   1        state=wait_input();
 313   1        //如果状态为1，表示退出
 314   1        if(state==1)
 315   1        {
 316   2          //返回1
 317   2          return 1;
 318   2        }
 319   1        //无限循环，直到检测到有效输入
 320   1        while(1)
 321   1        {
 322   2        //调用clear函数，清屏
 323   2        clear();
 324   2        //用循环语句，将a数组的所有元素初始化为0
 325   2        for(i=0;i<5;i++)
 326   2        {
 327   3          a[i]=0;
 328   3        }
 329   2        //用循环语句，从键盘获取输入的显示时间，并存储在a数组中
 330   2        for(i=0;i<6;i++)
 331   2        {
 332   3          //调用kscan函数，获取按键对应的值
 333   3          digit=kscan();
 334   3          //如果循环计数小于5，且按键对应的值在0到9之间，表示输入的是数字
 335   3          if(i<5&digit>=0&digit<=9)
 336   3          {
 337   4            //将按键对应的值存储在a数组中
 338   4            a[i]=digit;
 339   4            //调用print_char函数，在指定位置显示输入的数字
 340   4            print_char(0,0,digit+48);
 341   4          }
 342   3          //如果循环计数大于0，且按键对应的值为15，表示输入结束
 343   3          else if(i>0&digit==15)
 344   3          {
 345   4            //将a数组中的五个数字组合成一个显示时间，存储在temp变量中
 346   4            temp=0;
 347   4            for(j=0;j<i;j++)
 348   4            {
 349   5              temp=10*temp+a[j];
 350   5            }
 351   4            //如果temp变量的值在50到65535之间，表示输入的显示时间有效
 352   4            if(temp>=50&temp<=65535)
 353   4            {
 354   5              //将temp变量的值赋给display_time变量
 355   5              display_time=temp;
 356   5              //返回0
 357   5              return 0;
 358   5            }
 359   4            //如果temp变量的值不在50到65535之间，表示输入的显示时间无效
 360   4            else
 361   4            {
 362   5              //调用wrong_display_time函数，显示错误信息，并获取状态
 363   5              if(wrong_display_time())
 364   5              {
C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 7   

 365   6                //如果状态为1，表示退出
 366   6                return 1;
 367   6              }
 368   5              //如果状态为0，表示继续
 369   5              else
 370   5              {
 371   6                //跳出循环
 372   6                break;
 373   6              }
 374   5            }
 375   4          }
 376   3          //如果按键对应的值为14，表示退出
 377   3          else if(digit==14)
 378   3          {
 379   4            //返回1
 380   4            return 1;
 381   4          }
 382   3          //如果循环计数大于0，且按键对应的值为13，表示重新输入
 383   3          else if(i>0&digit==13)
 384   3          {
 385   4            break;
 386   4          }
 387   3          //如果以上条件都不满足，表示输入无效，循环计数不变
 388   3          else
 389   3          {
 390   4            i--;
 391   4          }
 392   3        }
 393   2        }
 394   1      }
 395          //定义一个函数，用于等待输入，并返回是否继续或退出的状态
 396          bit wait_input(void)
 397          {
 398   1        //定义一个位变量，用于存储状态
 399   1        bit state=0;
 400   1        //定义一个无符号字符变量，用于存储按键对应的值
 401   1        unsigned char temp;
 402   1        //无限循环，直到检测到有效按键
 403   1        while(1)
 404   1        {
 405   2          //调用kscan函数，获取按键对应的值
 406   2          temp=kscan();
 407   2          //如果按键对应的值在0到15之间，表示输入有效
 408   2          if(temp>=0&temp<=15)
 409   2          {
 410   3            //如果按键对应的值为14，表示退出，状态为1
 411   3            if(temp==14)
 412   3            {
 413   4              state=1;
 414   4            }
 415   3            //返回状态
 416   3            return state;
 417   3          }
 418   2        }
 419   1      }
 420          //定义一个函数，用于显示输入位数错误的信息，并返回是否继续或退出的状态
 421          bit wrong_input_bits(void)
 422          {
 423   1        //调用display_wrong_input_bits函数，显示错误信息
 424   1        display_wrong_input_bits();
 425   1        //调用f_or_e函数，判断是否继续或退出，并返回状态
 426   1        return f_or_e();
C51 COMPILER V9.60.7.0   KEYBOARD                                                          12/22/2023 09:21:57 PAGE 8   

 427   1      }
 428          //定义一个函数，用于显示输入显示时间错误的信息，并返回是否继续或退出的状态
 429          bit wrong_display_time(void)
 430          {
 431   1        //调用display_wrong_input_display_time函数，显示错误信息
 432   1        display_wrong_input_display_time();
 433   1        //调用f_or_e函数，判断是否继续或退出，并返回状态
 434   1        return f_or_e();
 435   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1165    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =     64    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
