C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE KEYBOARD
OBJECT MODULE PLACED IN .\Objects\keyboard.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE keyboard.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -keyboard.lst) TABS(2) OBJECT(.\Objects\keyboard.obj)

line level    source

*** WARNING C500 IN LINE 1 OF keyboard.c: LICENSE ERROR (R207(3): REGISTRY READ ERROR)

   1          /*
   2           * @Author: 王心瀚
   3           * @Date: 2023-11-23 22:02:43
   4           * @LastEditors: 王心瀚
   5           * @LastEditTime: 2023-12-25 10:39:36
   6           * @FilePath: \undefinedc:\Users\u2021\Desktop\资料\大三\单片机\实验\提高实验\C语言版本\keyboard.c
   7           * @Description: 键盘处理文件，包含键盘检测、数据输入相关函数
   8           * 
   9           * Copyright (c) 2023 by ${王心瀚}, All Rights Reserved. 
  10           */
  11          //包含键盘相关的头文件
  12          #include "keyboard.h"
  13          //定义一个长度为64的无符号字符数组，用于存储输入的数字
  14          unsigned char xdata inputs[64];
  15          //定义一个函数，用于扫描键盘按键，并返回按键对应的值
  16          unsigned char kscan(void)
  17          {
  18   1        //定义四个无符号字符变量，用于存储按键的高低位、按键类型和临时值
  19   1        unsigned char data keyh,keyl,keytp,temp;
  20   1        //设置P1端口的高四位为推挽输出模式
  21   1        P1MDOUT=0xF0;
  22   1        //设置P1端口的低四位为高电平，做输入
  23   1        P1=0X0F; 
  24   1        //无限循环，直到检测到按键
  25   1        while(1)
  26   1        {
  27   2        //如果P1端口的低四位不全为高电平，说明有按键按下
  28   2        if(P1!=0X0F)
  29   2        { 
  30   3          //延时10毫秒，消除抖动
  31   3          delay_ms(10);
  32   3          //再次检测P1端口的低四位，如果仍然不全为高电平，说明按键有效
  33   3          if(P1!=0x0f)
  34   3          {
  35   4            //将P1端口的低四位赋值给keyl，作为按键的低位
  36   4            keyl=P1;
  37   4            //跳出循环
  38   4            break;
  39   4          }
  40   3        }
  41   2        }
  42   1          //设置P1端口的低四位为输出模式
  43   1          P1MDOUT=0x0F;
  44   1          //设置P1端口的高四位为高电平，做输入
  45   1          P1=0xf0;
  46   1          //延时10毫秒，消除抖动
  47   1          delay_ms(10);
  48   1          //将P1端口的高四位赋值给keyh，作为按键的高位
  49   1          keyh=P1;
  50   1          //将按键的高低位进行或运算，得到按键类型
  51   1          keytp=keyh|keyl;
  52   1          //根据按键类型，用switch语句判断按键对应的值
  53   1          switch(keytp)
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 2   

  54   1          {
  55   2            //如果按键类型为0xe7，对应的值为0
  56   2            case 0xe7: temp=0;break;
  57   2            //如果按键类型为0xd7，对应的值为1
  58   2            case 0xd7: temp=1;break;
  59   2            //如果按键类型为0xb7，对应的值为2
  60   2            case 0xb7: temp=2;break;
  61   2            //如果按键类型为0x77，对应的值为3
  62   2            case 0x77: temp=3;break;
  63   2            //如果按键类型为0xeb，对应的值为4
  64   2            case 0xeb: temp=4;break;
  65   2            //如果按键类型为0xdb，对应的值为5
  66   2            case 0xdb: temp=5;break;
  67   2            //如果按键类型为0xbb，对应的值为6
  68   2            case 0xbb: temp=6;break;
  69   2            //如果按键类型为0x7b，对应的值为7
  70   2            case 0x7b: temp=7;break;
  71   2            //如果按键类型为0xed，对应的值为8
  72   2            case 0xed: temp=8;break;
  73   2            //如果按键类型为0xdd，对应的值为9
  74   2            case 0xdd: temp=9;break;
  75   2            //如果按键类型为0xbd，对应的值为10
  76   2            case 0xbd: temp=10;break;
  77   2            //如果按键类型为0x7d，对应的值为11
  78   2            case 0x7d: temp=11;break;
  79   2            //如果按键类型为0xee，对应的值为12
  80   2            case 0xee: temp=12;break;
  81   2            //如果按键类型为0xde，对应的值为13
  82   2            case 0xde: temp=13;break;
  83   2            //如果按键类型为0xbe，对应的值为14
  84   2            case 0xbe: temp=14;break;
  85   2            //如果按键类型为0x7e，对应的值为15
  86   2            case 0x7e: temp=15;break;
  87   2            //如果按键类型不在以上范围内，不做任何操作
  88   2            default:break;
  89   2          }
  90   1        //设置P1端口的高四位为输出模式
  91   1        P1MDOUT=0xF0;
  92   1        //设置P1端口的低四位为高电平，做输入
  93   1        P1=0X0F; 
  94   1        //无限循环，直到检测到按键松开
  95   1        while(1)
  96   1        {
  97   2        //如果P1端口的低四位全为高电平，说明按键松开
  98   2        if(P1==0X0F)
  99   2        { 
 100   3          //延时10毫秒，消除抖动
 101   3          delay_ms(10);
 102   3                   
 103   3          //再次检测P1端口的低四位，如果仍然全为高电平，说明按键松开有效
 104   3          if(P1==0x0f)
 105   3          {
 106   4            //跳出循环
 107   4            break;
 108   4          }
 109   3        }
 110   2        }
 111   1        //返回按键对应的值
 112   1        return temp;
 113   1      }
 114          //定义一个函数，用于判断输入是F还是E
 115          bit f_or_e(void)
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 3   

 116          {
 117   1        //定义一个无符号字符变量，用于存储按键对应的值
 118   1        unsigned temp;
 119   1        //无限循环，直到检测到有效按键
 120   1        while(1)
 121   1        {
 122   2          //调用kscan函数，获取按键对应的值
 123   2          temp=kscan();
 124   2          //如果按键对应的值为15(F)，一般情况表示继续，返回0
 125   2          if(temp==15)
 126   2          {
 127   3            //返回0
 128   3            return 0;
 129   3          }
 130   2          //如果按键对应的值为14(E)，表示退出，返回0
 131   2          else if(temp==14)
 132   2          {
 133   3            //返回1
 134   3            return 1;
 135   3          }
 136   2        }
 137   1      }
 138          //定义一个函数，用于输入数字，并存储在inputs数组中
 139          bit input_digits(void)
 140          {
 141   1        //定义两个无符号字符变量，用于存储循环计数和按键对应的值
 142   1        unsigned char i,digit=0;
 143   1        //定义一个位变量，用于存储是否继续或退出的状态
 144   1        bit state=0;
 145   1        //调用wait_input函数，等待输入，并获取状态
 146   1        state=wait_input();
 147   1        //如果状态为1，表示退出(输入了E)
 148   1        if(state==1)
 149   1        {
 150   2          //返回1
 151   2          return 1;
 152   2        }
 153   1        //无限循环，直到检测到有效输入
 154   1        while(1)
 155   1        {
 156   2        //调用clear函数，清屏
 157   2        clear();
 158   2        //用循环语句，将inputs数组的所有元素初始化为0
 159   2        for(i=0;i<64;i++)
 160   2        {
 161   3          inputs[i]=0;
 162   3        }
 163   2        //用循环语句，从键盘获取输入的数字，并存储在inputs数组中
 164   2        for(i=0;i<65;i++)
 165   2        {
 166   3          //调用kscan函数，获取按键对应的值
 167   3          digit=kscan();
 168   3          //如果循环计数小于64，且按键对应的值在0到9之间，表示输入的是数字
 169   3          if(i<64&digit>=0&digit<=9)
 170   3          {
 171   4            //将按键对应的值转换为ASCII码，存储在inputs数组中
 172   4            digit=inputs[i]=digits[digit];
 173   4            //根据循环计数，调用print_char函数，在不同的位置显示输入的数字
 174   4            if(i==16)
 175   4              {
 176   5                print_char(0,2,digit);
 177   5              }
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 4   

 178   4            else if(i==32)
 179   4              {
 180   5                print_char(0,3,digit);
 181   5              }
 182   4            else if(i==48)
 183   4              {
 184   5                print_char(0,4,digit);
 185   5              }
 186   4            else
 187   4              {
 188   5                print_char(0,0,digit);
 189   5              }
 190   4          }
 191   3          //如果循环计数大于0，且按键对应的值为15，表示输入结束
 192   3          else if(i>0&digit==15)
 193   3          {
 194   4            //返回0
 195   4            return 0;
 196   4          }
 197   3          //如果按键对应的值为14，表示退出
 198   3          else if(digit==14)
 199   3          {
 200   4            //返回1
 201   4            return 1;
 202   4          }
 203   3          //如果循环计数大于0，且按键对应的值为13，表示重新输入
 204   3          else if(i>0&digit==13)
 205   3          {
 206   4            break;
 207   4          }
 208   3          //如果循环计数大于0，且按键对应的值为12，表示退格
 209   3          else if(i>0&digit==12)
 210   3          {
 211   4            if(i%2==1)
 212   4            {
 213   5              //如果输入的数字是12，并且输入的数字是奇数，则打印空格
 214   5              // 打印空格字符
 215   5              print_char(0, 0, 0x20);
 216   5              // 循环计数器减1
 217   5              i--;
 218   5              // 将输入数组中的第i个元素设置为0
 219   5              inputs[i] = 0;
 220   5              // 执行光标移动操作，左移一位
 221   5              cursor_shift_contorl();
 222   5              // 打印两个空格字符
 223   5              print_char(0, 0, 0x20);
 224   5              print_char(0, 0, 0x20);
 225   5              // 执行光标移动操作，左移一位
 226   5              cursor_shift_contorl();
 227   5              // 循环计数器减1
 228   5              i--;
 229   5      
 230   5            }
 231   4            if(i%2==0)
 232   4            {
 233   5              //如果输入的数字是12，并且输入的数字是偶数
 234   5              if(i==16)
 235   5              {
 236   6                //如果输入的数字是16
 237   6                // 循环计数器减1
 238   6                i--;
 239   6                // 将输入数组中的第i个元素设置为0
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 5   

 240   6                inputs[i] = 0;
 241   6                // 循环计数器减1
 242   6                i--;
 243   6                // 获取输入数组中的第i个元素
 244   6                digit = inputs[i];
 245   6                // 在第一行第7列打印一个空格字符
 246   6                print_char(7, 1, 0x20);
 247   6                // 打印一个空格字符
 248   6                print_char(0, 0, 0x20);
 249   6                // 在第一行第7列打印数字
 250   6                print_char(7, 1, digit);
 251   6              }
 252   5              else if(i==32)
 253   5              {
 254   6                //如果输入的数字是32
 255   6                // 循环计数器减1
 256   6                i--;
 257   6                // 将输入数组中的第i个元素设置为0
 258   6                inputs[i]=0;
 259   6                // 循环计数器减1
 260   6                i--;
 261   6                // 获取输入数组中的第i个元素
 262   6                digit=inputs[i];
 263   6                // 在第2行第7列打印一个空格字符
 264   6                print_char(7,2,0x20);
 265   6                // 打印一个空格字符
 266   6                print_char(0,0,0x20);
 267   6                // 在第2行第7列打印数字
 268   6                print_char(7,2,digit);
 269   6              }
 270   5              else if(i==48)
 271   5              {
 272   6                //如果输入的数字是48
 273   6                // 循环计数器减1
 274   6                i--;
 275   6                // 将输入数组中的第i个元素设置为0
 276   6                inputs[i]=0;
 277   6                // 循环计数器减1
 278   6                i--;
 279   6                // 获取输入数组中的第i个元素
 280   6                digit=inputs[i];
 281   6                // 在第3行第7列打印一个空格字符
 282   6                print_char(7,3,0x20);
 283   6                // 打印一个空格字符
 284   6                print_char(0,0,0x20);
 285   6                // 在第3行第7列打印数字
 286   6                print_char(7,3,digit);
 287   6              }
 288   5              else
 289   5              {
 290   6                //如果输入的数字不是16，32，48
 291   6                // 循环计数器减1
 292   6                i--;
 293   6                // 将输入数组中的第i个元素设置为0
 294   6                inputs[i]=0;
 295   6                // 循环计数器减1
 296   6                i--;
 297   6                // 获取输入数组中的第i个元素
 298   6                digit=inputs[i];
 299   6                // 执行光标移动操作，左移一位
 300   6                cursor_shift_contorl();
 301   6                // 打印一个空格字符
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 6   

 302   6                print_char(0,0,0x20);
 303   6                // 打印一个空格字符
 304   6                print_char(0,0,0x20);
 305   6                // 执行光标移动操作，左移一位
 306   6                cursor_shift_contorl();
 307   6                // 打印数字
 308   6                print_char(0,0,digit);
 309   6              }
 310   5            }
 311   4          }
 312   3          //如果以上条件都不满足，表示输入无效，循环计数不变
 313   3          else
 314   3          {
 315   4            i--;
 316   4          }
 317   3        }
 318   2        }
 319   1      }
 320          //定义一个函数，用于输入位数，并存储在bits变量中
 321          bit input_bits(void)
 322          {
 323   1        //定义两个无符号字符变量，用于存储循环计数和按键对应的值
 324   1        unsigned char i,digit=0;
 325   1        //定义一个长度为2的无符号字符数组，用于存储输入的位数
 326   1        unsigned char a[2]={0};
 327   1        //定义一个位变量，用于存储是否继续或退出的状态
 328   1        bit state=0;
 329   1        //调用wait_input函数，等待输入，并获取状态
 330   1        state=wait_input();
 331   1        //如果状态为1，表示退出
 332   1        if(state==1)
 333   1        {
 334   2          //返回1
 335   2          return 1;
 336   2        }
 337   1        //无限循环，直到检测到有效输入
 338   1        while(1)
 339   1        {
 340   2        //调用clear函数，清屏
 341   2        clear();
 342   2        //用循环语句，将a数组的所有元素初始化为0
 343   2        for(i=0;i<2;i++)
 344   2        {
 345   3          a[i]=0;
 346   3        }
 347   2        //用循环语句，从键盘获取输入的位数，并存储在a数组中
 348   2        for(i=0;i<3;i++)
 349   2        {
 350   3          //调用kscan函数，获取按键对应的值
 351   3          digit=kscan();
 352   3          //如果循环计数小于2，且按键对应的值在0到9之间，表示输入的是数字
 353   3          if(i<2&digit>=0&digit<=9)
 354   3          {
 355   4            //将按键对应的值存储在a数组中
 356   4            a[i]=digit;
 357   4            //调用print_char函数，在指定位置显示输入的数字
 358   4            print_char(0,0,digit+48);
 359   4          }
 360   3          //如果循环计数大于0，且按键对应的值为15，表示输入结束
 361   3          else if(i>0&digit==15)
 362   3          {
 363   4            //将a数组中的两个数字组合成一个位数，存储在全局变量bits中
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 7   

 364   4            if(i==1)
 365   4            {
 366   5              bits=a[0];
 367   5            }
 368   4            else
 369   4            {
 370   5            bits=a[0]*10+a[1];
 371   5            }
 372   4            //如果bits变量的值在1到64之间，表示输入的位数有效
 373   4            if(bits>=1&bits<=64)
 374   4            {
 375   5            //返回0
 376   5            return 0;
 377   5            }
 378   4            //如果bits变量的值不在1到64之间，表示输入的位数无效
 379   4            else
 380   4            {
 381   5              //调用wrong_input_bits函数，显示错误信息，并获取状态
 382   5              if(wrong_input_bits())
 383   5              {
 384   6                //如果状态为1，表示退出
 385   6                return 1;
 386   6              }
 387   5              //如果状态为0，表示继续
 388   5              else
 389   5              {
 390   6                //跳出循环
 391   6                break;
 392   6              }
 393   5            }
 394   4          }
 395   3          //如果按键对应的值为14，表示退出
 396   3          else if(digit==14)
 397   3          {
 398   4            //返回1
 399   4            return 1;
 400   4          }
 401   3          //如果循环计数大于0，且按键对应的值为12，表示退格
 402   3          else if(i>0&digit==12)
 403   3          {
 404   4            if(i%2==1)
 405   4            {
 406   5              print_char(0,0,0x20);
 407   5              i--;
 408   5              a[i]=0;
 409   5              cursor_shift_contorl();
 410   5              print_char(0,0,0x20);
 411   5              print_char(0,0,0x20);
 412   5              cursor_shift_contorl();
 413   5              i--;
 414   5            }
 415   4            if(i%2==0)
 416   4            {
 417   5              i--;
 418   5              a[i]=0;
 419   5              i--;
 420   5              digit=a[i];
 421   5              cursor_shift_contorl();
 422   5              print_char(0,0,0x20);
 423   5              print_char(0,0,0x20);
 424   5              cursor_shift_contorl();
 425   5              print_char(0,0,digit+48);
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 8   

 426   5            }
 427   4          }
 428   3          //如果循环计数大于0，且按键对应的值为13，表示重新输入
 429   3          else if(i>0&digit==13)
 430   3          {
 431   4            break;
 432   4          }
 433   3          //如果以上条件都不满足，表示输入无效，循环计数不变
 434   3          else
 435   3          {
 436   4            i--;
 437   4          }
 438   3        }
 439   2        }
 440   1      }
 441          //定义一个函数，用于输入显示时间，并存储在display_time变量中
 442          bit input_display_time(void)
 443          {
 444   1        //定义两个无符号字符变量，用于存储循环计数和按键对应的值
 445   1        unsigned char i,j,digit=0;
 446   1        //定义一个长度为5的无符号字符数组，用于存储输入的显示时间
 447   1        unsigned char a[5]={0};
 448   1        //定义一个无符号长整数变量，用于存储输入的显示时间
 449   1        unsigned long temp;
 450   1        //定义一个位变量，用于存储是否继续或退出的状态
 451   1        bit state=0;
 452   1        //调用wait_input函数，等待输入，并获取状态
 453   1        state=wait_input();
 454   1        //如果状态为1，表示退出
 455   1        if(state==1)
 456   1        {
 457   2          //返回1
 458   2          return 1;
 459   2        }
 460   1        //无限循环，直到检测到有效输入
 461   1        while(1)
 462   1        {
 463   2        //调用clear函数，清屏
 464   2        clear();
 465   2        //用循环语句，将a数组的所有元素初始化为0
 466   2        for(i=0;i<5;i++)
 467   2        {
 468   3          a[i]=0;
 469   3        }
 470   2        //用循环语句，从键盘获取输入的显示时间，并存储在a数组中
 471   2        for(i=0;i<6;i++)
 472   2        {
 473   3          //调用kscan函数，获取按键对应的值
 474   3          digit=kscan();
 475   3          //如果循环计数小于5，且按键对应的值在0到9之间，表示输入的是数字
 476   3          if(i<5&digit>=0&digit<=9)
 477   3          {
 478   4            //将按键对应的值存储在a数组中
 479   4            a[i]=digit;
 480   4            //调用print_char函数，在指定位置显示输入的数字
 481   4            print_char(0,0,digit+48);
 482   4          }
 483   3          //如果循环计数大于0，且按键对应的值为15，表示输入结束
 484   3          else if(i>0&digit==15)
 485   3          {
 486   4            //将a数组中的五个数字组合成一个显示时间，存储在temp变量中
 487   4            temp=0;
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 9   

 488   4            for(j=0;j<i;j++)
 489   4            {
 490   5              temp=10*temp+a[j];
 491   5            }
 492   4            //如果temp变量的值在50到65535之间，表示输入的显示时间有效
 493   4            if(temp>=50&temp<=65535)
 494   4            {
 495   5              //将temp变量的值赋给display_time变量
 496   5              display_time=temp;
 497   5              //返回0
 498   5              return 0;
 499   5            }
 500   4            //如果temp变量的值不在50到65535之间，表示输入的显示时间无效
 501   4            else
 502   4            {
 503   5              //调用wrong_display_time函数，显示错误信息，并获取状态
 504   5              if(wrong_display_time())
 505   5              {
 506   6                //如果状态为1，表示退出
 507   6                return 1;
 508   6              }
 509   5              //如果状态为0，表示继续
 510   5              else
 511   5              {
 512   6                //跳出循环
 513   6                break;
 514   6              }
 515   5            }
 516   4          }
 517   3          //如果按键对应的值为14，表示退出
 518   3          else if(digit==14)
 519   3          {
 520   4            //返回1
 521   4            return 1;
 522   4          }
 523   3          //如果循环计数大于0，且按键对应的值为13，表示重新输入
 524   3          else if(i>0&digit==13)
 525   3          {
 526   4            break;
 527   4          }
 528   3          //如果循环计数大于0，且按键对应的值为12，表示退格
 529   3          else if(i>0&digit==12)
 530   3          {
 531   4            if(i%2==1)
 532   4            {
 533   5              print_char(0,0,0x20);
 534   5              i--;
 535   5              a[i]=0;
 536   5              cursor_shift_contorl();
 537   5              print_char(0,0,0x20);
 538   5              print_char(0,0,0x20);
 539   5              cursor_shift_contorl();
 540   5              i--;
 541   5            }
 542   4            if(i%2==0)
 543   4            {
 544   5              i--;
 545   5              a[i]=0;
 546   5              i--;
 547   5              digit=a[i];
 548   5              cursor_shift_contorl();
 549   5              print_char(0,0,0x20);
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 10  

 550   5              print_char(0,0,0x20);
 551   5              cursor_shift_contorl();
 552   5              print_char(0,0,digit+48);
 553   5            }
 554   4          }
 555   3          //如果以上条件都不满足，表示输入无效，循环计数不变
 556   3          else
 557   3          {
 558   4            i--;
 559   4          }
 560   3        }
 561   2        }
 562   1      }
 563          //定义一个函数，用于等待输入，并返回是否继续或退出的状态
 564          bit wait_input(void)
 565          {
 566   1        //定义一个位变量，用于存储状态
 567   1        bit state=0;
 568   1        //定义一个无符号字符变量，用于存储按键对应的值
 569   1        unsigned char temp;
 570   1        //无限循环，直到检测到有效按键
 571   1        while(1)
 572   1        {
 573   2          //调用kscan函数，获取按键对应的值
 574   2          temp=kscan();
 575   2          //如果按键对应的值在0到15之间，表示输入有效
 576   2          if(temp>=0&temp<=15)
 577   2          {
 578   3            //如果按键对应的值为14，表示退出，状态为1
 579   3            if(temp==14)
 580   3            {
 581   4              state=1;
 582   4            }
 583   3            //返回状态
 584   3            return state;
 585   3          }
 586   2        }
 587   1      }
 588          //定义一个函数，用于显示输入位数错误的信息，并返回是否继续或退出的状态
 589          bit wrong_input_bits(void)
 590          {
 591   1        //调用display_wrong_input_bits函数，显示错误信息
 592   1        display_wrong_input_bits();
 593   1        //调用f_or_e函数，判断是否继续或退出，并返回状态
 594   1        return f_or_e();
 595   1      }
 596          //定义一个函数，用于显示输入显示时间错误的信息，并返回是否继续或退出的状态
 597          bit wrong_display_time(void)
 598          {
 599   1        //调用display_wrong_input_display_time函数，显示错误信息
 600   1        display_wrong_input_display_time();
 601   1        //调用f_or_e函数，判断是否继续或退出，并返回状态
 602   1        return f_or_e();
 603   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1741    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =     64    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      20
C51 COMPILER V9.60.7.0   KEYBOARD                                                          01/04/2025 19:16:53 PAGE 11  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
